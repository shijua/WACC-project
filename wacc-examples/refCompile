#!/usr/bin/env ruby
# command line script that sends an HTTPS request to the WACC compiler web interface and interprets the JSON response

require "rest-client"
require "json"
require "optparse"


ARGV << "-h" if ARGV.empty?

$options = {}
$opts = []
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] <target.wacc> \n  options:"

  $options[:parse_only] = false
  opts.on("-p", "--only-parse",
    "Parse only. Check the input file for syntax errors and generate an AST.") do
    $opts << "--only-parse" 
    $options[:parse_only] = true
  end

  $options[:semantic_check] = false
  opts.on("-s", "--only-typecheck",
    "Semantic check. Parse the file for syntax and semantic errors and generate an AST." ) do
    $opts << "--only-typecheck" 
    $options[:parse_only] = false
    $options[:semantic_check] = true
  end
  
  opts.on("-c", "--full-compile",
    "Full Compilation (default). Run the full compilation process." ) do
    $opts << "--full-compile"
    $options[:parse_only] = false
    $options[:semantic_check] = false
  end   
  
  $options[:target] = "aarch64"
  opts.on("-t [arch]", "--target [ARCH]", String,
    "Target. Select target architecture (default aarch64, options: arm32, x86-64-intel or x86-64).") do |arch|
    $opts << "--target #{arch}"
    $options[:target] = arch
  end
  
  $options[:optimise] = false
  opts.on("-o", "--optimise",
    "Optimise. Run ARM Peephole optimisations over the generated assembly code." ) do
    $opts << "--optimise"
    $options[:optimise] = true
  end   
  
  $options[:print_asm] = false
  opts.on("-a", "--print-assembly",
    "View Assembly. Display ARM assembly code generated by the code generator." ) do
    $opts << "--print-assembly" 
    $options[:print_asm] = true
  end  

  $options[:execute] = false
  opts.on("-x", "--execute",
    "Execute. Assemble and Emulate the generated ARM code and display its output." ) do
    $opts << "--execute" 
    $options[:execute] = true
  end

  $options[:directory] = false
  opts.on("-d", "--directory",
    "Give directory of wacc files." ) do
    $options[:directory] = true
  end

  opts.on_tail("-h", "--help",
    "Show this message") do
    puts opts
    puts ""
    puts "  target.wacc: path to wacc program file to compile (or target directory if --directory option set)"
    exit
  end

end.parse!

# set up empty array of file_paths to process
files = []
puts ARGV[0]
if $options[:directory] then
  # add the results of a search to the array
  files += Dir.glob(File.join(ARGV[0], "**", "*.wacc"))
else
  # just add the target file to the array
  files << ARGV[0]
end

# check that there is at least one file to process
if files == [] then
  puts "Error: no file(s) targeted"
  exit 1
end

# now process each target file
files.each do |file_path|
  puts "calling the reference compiler on #{file_path}"
  
  # get stdin from the user to pass to the reference compiler (removing any trailing newlines)
  stdin = ""
  if $options[:execute] then
    puts "please provide a stdin stream to use when executing the program:"
    stdin = STDIN.gets.rstrip
  end

  # make the call to the reference compiler
  RestClient.post("https://teaching.doc.ic.ac.uk/wacc_compiler/run.cgi", 
                    :stdin => stdin,
                    :options => $opts,
                    :testfile => File.new(file_path)
                   ) do |response|
    json = JSON.load(response)
    puts "-- Test: #{json['test']}"
    puts ""
    puts "-- Uploaded file: "
    puts "---------------------------------------------------------------"
    puts json['upload']
    puts "---------------------------------------------------------------"
    puts ""
    puts "-- Compiler Output:"
    puts json['compiler_out']
    puts ""
  end
  
end
